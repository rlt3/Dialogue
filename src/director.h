#ifndef DIALOGUE_DIRECTOR
#define DIALOGUE_DIRECTOR

#include "dialogue.h"

/*
 * Load the Director and all of the Workers.
 */
int
director_create ();

/*
 * Set the `director_action` function inside the Lua state as "Director".
 */
void
director_set (lua_State *L);

/*
 * The Director takes (and pops) whatever is on top of L and gives it to a
 * Worker and does no validation. The validation occurs at the Worker level,
 * where other errors might pop up from bad inputs.
 * 
 * From a random starting point (generated by the seed) 0..worker-max, we loop
 * through the workers until one isn't busy. Send the action to the open
 * worker. 
 *
 * An optional thread_id can be passed which tells the director which Worker
 * process to target. If the thread_id == 0, the Director handles the message 
 * itself on the main thread.
 *
 * Returns 0 if successful.
 */
int
director_take_action (lua_State *L);

/*
 * Transfer the Actions collected for the main thread to the given Lua stack.
 * Returns the number of actions transfered.
 */
int
director_transfer_main_actions (lua_State *L);

/*
 * Do the callback (an Action-level feature) in the Worker's Lua stack.
 * callback_id is the index of the function in the callback table in the
 * Worker's Lua stack.
 * Any errors are printed to the console.
 */
int
director_callback (int worker_id, int callback_id);

/*
 * Close the Director and all of the Workers.
 */
void
director_close ();

#endif
