#include <stdlib.h>
#include <time.h>
#include <sys/time.h>
#include "director.h"
#include "action.h"
#include "worker.h"
#include "mailbox.h"

struct Director {
    Worker **workers;
    int worker_count;
    Mailbox *main_mailbox;
    int rand_seed;
    struct timeval start;
    struct timeval now;
};

static Director *global_director = NULL;

/*
 * Create the Director and N workers where N is `workers`. Each worker is 
 * allocated a mailbox and the Director itself has a mailbox for the main
 * thread.
 *
 * Returns 0 if successfuly, >0 if the system didn't have enough memory.
 */
int
director_create (const int workers)
{
    int ret = 1;
    int i, j;

    global_director = malloc(sizeof(*director));

    if (!global_director)
        goto exit;

    director->workers = malloc(sizeof(Worker*) * workers);

    if (!director->workers) {
        free(director);
        goto exit;
    }

    director->mailbox = mailbox_create();

    if (!director->mailbox) {
        free(director->workers);
        free(director);
        goto exit;
    }

    /* set memory to NULL so if an error occurs, NULL checks will catch */
    for (i = 0; i < director->worker_count; i++)
        director->workers[i] = NULL;

    for (i = 0; i < director->worker_count; i++) { 
        director->workers[i] = worker_start();
        
        if (!director->workers[i]) {
            director_close();
            goto exit;
        }
    }

    director->rand_seed = time(NULL);
    srand(director->rand_seed);

    gettimeofday(&director->start, NULL);
    director->now = director->start;

    ret = 0;
exit:
    return ret;
}

/*
 * Expects an Action on top of the Lua stack in the form:
 *     { action, actor [, data1 [, ... [, dataN]]] }
 *
 * From a random starting point (generated by the seed) 0..worker-max, we loop
 * through the workers until one isn't busy. Send the action to the open
 * worker.  Returns 0 if successful.
 *
 * An example:
 *     { OP_BENCH, bullet }
 *     { OP_SEND, player, "input", "JOYSTICK-FIRE" }
 *     { OP_LOAD, bullet, "location", x, y }
 *     { OP_JOIN, bullet }
 *     { OP_SEND, bullet, "target", 30, 40 }
 */
int
director_action (lua_State *L)
{
    int count, start, i;

    luaL_checktype(L, -1, LUA_TTABLE);

    count = global_director->worker_count;
    start = rand() % count;

    for (i = start; i < count; i = (i + 1) % count)
        if (worker_pop_action(global_director->workers[i], L))
            break;

    return 0;
}

/*
 * Close the Director and all of the Workers.
 */
int
director_close ()
{
    int i;

    /* stop everything first */
    for (i = 0; i < global_director->worker_count; i++)
        worker_stop(global_director->workers[i]);

    /* then cleanup, it avoids a lot of problems */
    for (i = 0; i < global_director->worker_count; i++)
        worker_cleanup(global_director->workers[i]);

    mailbox_destroy(global_director->mailbox);
    free(global_director->workers);
    free(global_director);
}
