#include <stdlib.h>
#include <time.h>
#include <sys/time.h>
#include "director.h"
#include "worker.h"

typedef struct Director {
    Worker **workers;
    int worker_count;
    Worker *main_thread_worker;
    int rand_seed;
    struct timeval start;
    struct timeval now;
} Director;

static Director *global_director = NULL;

/*
 * Create the Director and N workers where N is `workers`. Each worker is 
 * allocated a mailbox and the Director itself has a mailbox for the main
 * thread.
 *
 * Returns 0 if successfuly, >0 if the system didn't have enough memory.
 */
int
director_create (const int num_workers)
{
    int i, ret = 1;

    global_director = malloc(sizeof(*global_director));

    if (!global_director)
        goto exit;

    global_director->workers = malloc(sizeof(Worker*) * num_workers);

    if (!global_director->workers) {
        free(global_director);
        goto exit;
    }

    global_director->main_thread_worker = worker_create();

    if (!global_director->main_thread_worker) {
        free(global_director->workers);
        free(global_director);
        goto exit;
    }

    /* set memory to NULL so if an error occurs, NULL checks will catch */
    for (i = 0; i < num_workers; i++)
        global_director->workers[i] = NULL;

    for (i = 0; i < num_workers; i++) { 
        global_director->workers[i] = worker_start();
        
        if (!global_director->workers[i]) {
            director_close();
            goto exit;
        }
    }

    global_director->worker_count = num_workers;

    global_director->rand_seed = time(NULL);
    srand(global_director->rand_seed);

    gettimeofday(&global_director->start, NULL);
    global_director->now = global_director->start;

    ret = 0;
exit:
    return ret;
}

/*
 * Set the `director_action` function inside the Lua state as "Director".
 */
void
director_set (lua_State *L)
{
    lua_pushcfunction(L, director_action);
    lua_setglobal(L, "Director");
}

/*
 * Expects an Action on top of the Lua stack in the form:
 *     { action, actor [, data1 [, ... [, dataN]]] }
 *
 * From a random starting point (generated by the seed) 0..worker-max, we loop
 * through the workers until one isn't busy. Send the action to the open
 * worker. 
 *
 * An optional thread_id can be passed which tells the director which Worker
 * process to target. If the thread_id == 0, the Director handles the message 
 * itself on the main thread.
 *
 * Returns 0 if successful.
 *
 * An example:
 *     { OP_BENCH, bullet }
 *     { OP_SEND, player, "input", "JOYSTICK-FIRE" }
 *     { OP_LOAD, bullet, "location", x, y }
 *     { OP_JOIN, bullet }
 *     { OP_SEND, bullet, "target", 30, 40 }
 */
int
director_action (lua_State *L)
{
    const int table_arg = 1;
    const int opt_thread_arg = 2;
    int count, start, i, args = lua_gettop(L);

    if (args == opt_thread_arg) {
        /* TODO: choosing a specific thread! */
    }

    luaL_checktype(L, table_arg, LUA_TTABLE);

    count = global_director->worker_count;
    start = rand() % count;

    for (i = start; i < count; i = (i + 1) % count)
        if (worker_take_action(global_director->workers[i], L) == 0)
            break;

    return 0;
}

/*
 * Close the Director and all of the Workers.
 */
void
director_close ()
{
    int i;

    /* stop everything first */
    for (i = 0; i < global_director->worker_count; i++)
        worker_stop(global_director->workers[i]);

    /* then cleanup, it avoids a lot of problems */
    for (i = 0; i < global_director->worker_count; i++)
        worker_cleanup(global_director->workers[i]);

    worker_cleanup(global_director->main_thread_worker);
    free(global_director->workers);
    free(global_director);
}
